"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var gulp = require('gulp'), gutil = require('gulp-util'), iconfont = require('gulp-iconfont'), template = require('gulp-template'), rename = require('gulp-rename'), mergeStream = require('merge-stream');
var PLUGIN_NAME = 'ionic2-custom-icons', FONT_NAME_PREFIX = 'custom-icons-', FILENAME_PREFIX = FONT_NAME_PREFIX;
function gulpCustomIcons(config) {
    // One gulp stream for each icon set
    var streams = [];
    var _loop_1 = function (iconSet) {
        gutil.log(PLUGIN_NAME + ': Creating custom icon set \'' + iconSet.id + '\'');
        var fontName = FONT_NAME_PREFIX + iconSet.id;
        // run gulp tasks: iconfont, iconfontCSS
        var stream = gulp.src([iconSet.src])
            .pipe(iconfont({
            fontName: fontName,
            formats: ['ttf', 'eot', 'woff', 'woff2', 'svg'],
            normalize: true,
            centerHorizontally: true,
            fontHeight: 1000
        }))
            .on('glyphs', function (glyphs, options) {
            var setClass = iconSet.id;
            processGlyphs(glyphs, setClass);
            gulp.src(config.templatePath)
                .pipe(template({
                glyphs: glyphs,
                fontName: fontName,
                setClass: setClass,
                fontPath: config.fontRelPath
            }))
                .pipe(rename(FILENAME_PREFIX + iconSet.id + '.scss'))
                .pipe(gulp.dest(config.scssTargetPath));
        })
            .pipe(gulp.dest(config.fontTargetPath));
        streams.push(stream);
    };
    for (var _i = 0, _a = config.iconSets; _i < _a.length; _i++) {
        var iconSet = _a[_i];
        _loop_1(iconSet);
    }
    // return merged streams of all icon sets
    return mergeStream(streams);
}
exports.gulpCustomIcons = gulpCustomIcons;
/**
 * Process glyphs and set class name based on its filename
 * @param glyphs
 * @param setClass
 */
function processGlyphs(glyphs, setClass) {
    for (var _i = 0, glyphs_1 = glyphs; _i < glyphs_1.length; _i++) {
        var glyph = glyphs_1[_i];
        var namePartsTmp = glyph.name.split('-'), curNamePart = namePartsTmp.splice(-1)[0], iconClassTmp = '';
        // inactive class
        if (curNamePart === 'inactive') {
            iconClassTmp = '.inactive';
            curNamePart = namePartsTmp.splice(-1)[0];
        }
        // mode class
        if (curNamePart === 'ios' || curNamePart === 'md' || curNamePart === 'wp') {
            iconClassTmp = '.' + curNamePart + iconClassTmp;
            curNamePart = namePartsTmp.splice(-1)[0];
        }
        // Prepend base name
        iconClassTmp = curNamePart + iconClassTmp;
        if (namePartsTmp.length) {
            iconClassTmp = namePartsTmp.join('-') + '-' + iconClassTmp;
        }
        // combined classes of glyph
        glyph.class = 'custom-icon.' + 'set-' + setClass + '.' + 'icon-' + iconClassTmp;
        // unicode string of glyph
        glyph.char = glyph.unicode[0].charCodeAt(0).toString(16).toUpperCase();
    }
}
